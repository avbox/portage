diff --git a/include/libtorrent/alert_types.hpp b/include/libtorrent/alert_types.hpp
index b4bc434..51b497f 100644
--- a/include/libtorrent/alert_types.hpp
+++ b/include/libtorrent/alert_types.hpp
@@ -2507,12 +2507,30 @@ namespace libtorrent
 #endif // TORRENT_DISABLE_LOGGING
 	};
 
+	// This alert is generated when a piece has passed the hash check and has
+	// been written to disk (so it can be safely read). This alert may be generated
+	// more than once for each piece.
+	struct TORRENT_EXPORT piece_ready_alert TORRENT_FINAL : torrent_alert
+	{
+		// internal
+		piece_ready_alert(aux::stack_allocator& alloc, torrent_handle h
+			, int piece_num);
+
+		TORRENT_DEFINE_ALERT(piece_ready_alert, 90)
+
+		static const int static_category = alert::progress_notification;
+		virtual std::string message() const TORRENT_OVERRIDE;
+
+		int piece_index;
+	};
+
+
 #undef TORRENT_DEFINE_ALERT_IMPL
 #undef TORRENT_DEFINE_ALERT
 #undef TORRENT_DEFINE_ALERT_PRIO
 #undef TORRENT_CLONE
 
-	enum { num_alert_types = 90 }; // this enum represents "max_alert_index" + 1
+	enum { num_alert_types = 91 }; // this enum represents "max_alert_index" + 1
 }
 
 
diff --git a/include/libtorrent/piece_picker.hpp b/include/libtorrent/piece_picker.hpp
index 5f726f2..4d7b181 100644
--- a/include/libtorrent/piece_picker.hpp
+++ b/include/libtorrent/piece_picker.hpp
@@ -391,6 +391,10 @@ namespace libtorrent
 		// or if we have the piece
 		bool is_piece_finished(int index) const;
 
+		// returns true if all blocks in this piece are finished
+		// and have been written to disk
+		bool is_piece_ready(int index) const;
+
 		// returns true if we have the piece or if the piece
 		// has passed the hash check
 		bool has_piece_passed(int index) const;
diff --git a/src/alert.cpp b/src/alert.cpp
index e7b7a25..8bcf5a3 100644
--- a/src/alert.cpp
+++ b/src/alert.cpp
@@ -593,6 +593,22 @@ namespace libtorrent {
 		return ret;
 	}
 
+	piece_ready_alert::piece_ready_alert(aux::stack_allocator& alloc, torrent_handle h
+		, int piece_num)
+		: torrent_alert(alloc, h)
+		, piece_index(piece_num)
+	{
+		TORRENT_ASSERT(piece_index >= 0);
+	}
+
+	std::string piece_ready_alert::message() const
+	{
+		char ret[200];
+		snprintf(ret, sizeof(ret), "%s piece %i is ready"
+			, torrent_alert::message().c_str(), piece_index);
+		return ret;
+	}
+
 	block_downloading_alert::block_downloading_alert(aux::stack_allocator& alloc, torrent_handle h
 		, tcp::endpoint const& ep
 		, peer_id const& peer_id, int block_num, int piece_num)
diff --git a/src/peer_connection.cpp b/src/peer_connection.cpp
index 630676d..b0ea2db 100644
--- a/src/peer_connection.cpp
+++ b/src/peer_connection.cpp
@@ -3055,6 +3055,15 @@ namespace libtorrent
 //			, peer_info_struct(), block_finished.piece_index, block_finished.block_index);
 		picker.mark_as_finished(block_finished, peer_info_struct());
 
+		if (t->alerts().should_post<piece_ready_alert>())
+		{
+			if (picker.is_piece_ready(block_finished.piece_index))
+			{
+				t->alerts().emplace_alert<piece_ready_alert>(t->get_handle(),
+					int(block_finished.piece_index));
+			}
+		}
+
 		t->maybe_done_flushing();
 
 		if (t->alerts().should_post<block_finished_alert>())
diff --git a/src/piece_picker.cpp b/src/piece_picker.cpp
index ac75969..c1b67a9 100644
--- a/src/piece_picker.cpp
+++ b/src/piece_picker.cpp
@@ -2908,6 +2908,26 @@ get_out:
 		return true;
 	}
 
+	bool piece_picker::is_piece_ready(int index) const
+	{
+		if (!is_piece_finished(index))
+			return false;
+
+		piece_pos const& p = m_piece_map[index];
+		int state = p.download_queue();
+
+		if (state < piece_pos::num_download_categories)
+		{
+			std::vector<downloading_piece>::const_iterator i =
+				find_dl_piece(state, index);
+			TORRENT_ASSERT(i != m_downloads[state].end());
+			if (int(i->finished) < blocks_in_piece(index))
+				return false;
+		}
+
+		return true;
+	}
+
 	bool piece_picker::has_piece_passed(int index) const
 	{
 		TORRENT_ASSERT(index < int(m_piece_map.size()));
diff --git a/src/torrent.cpp b/src/torrent.cpp
index 2319557..8758dc8 100644
--- a/src/torrent.cpp
+++ b/src/torrent.cpp
@@ -1488,6 +1488,16 @@ namespace libtorrent
 		if (picker().is_finished(block_finished)) return;
 
 		picker().mark_as_finished(block_finished, 0);
+
+		if (alerts().should_post<piece_ready_alert>())
+		{
+			if (picker().is_piece_ready(block_finished.piece_index))
+			{
+				alerts().emplace_alert<piece_ready_alert>(get_handle(),
+					block_finished.piece_index);
+			}
+		}
+
 		maybe_done_flushing();
 	}
 
@@ -4290,6 +4300,17 @@ namespace {
 
 		inc_stats_counter(counters::num_have_pieces);
 
+		if (m_ses.alerts().should_post<piece_finished_alert>())
+			m_ses.alerts().emplace_alert<piece_finished_alert>(get_handle(), index);
+
+		if (alerts().should_post<piece_ready_alert>())
+		{
+			if (has_picker() && picker().is_piece_ready(index))
+			{
+				alerts().emplace_alert<piece_ready_alert>(get_handle(), index);
+			}
+		}
+
 		// at this point, we have the piece for sure. It has been
 		// successfully written to disk. We may announce it to peers
 		// (unless it has already been announced through predictive_piece_announce
@@ -4368,9 +4389,6 @@ namespace {
 		set_need_save_resume();
 		state_updated();
 
-		if (m_ses.alerts().should_post<piece_finished_alert>())
-			m_ses.alerts().emplace_alert<piece_finished_alert>(get_handle(), index);
-
 		// update m_file_progress (if we have one)
 		m_file_progress.update(m_torrent_file->files(), index
 			, &m_ses.alerts(), get_handle());
