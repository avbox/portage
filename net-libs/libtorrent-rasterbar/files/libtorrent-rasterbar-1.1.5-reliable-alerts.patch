commit 60086fb9a2e4e1baabd5352f69e29408ebef47c4
Author: Fernando Rodriguez <frodzdev@gmail.com>
Date:   Wed Mar 28 00:49:08 2018 -0400

    Implement reliable alerts
    
    This is a work in progress.

diff --git a/include/libtorrent/alert_manager.hpp b/include/libtorrent/alert_manager.hpp
index 017240264..c8bba2637 100644
--- a/include/libtorrent/alert_manager.hpp
+++ b/include/libtorrent/alert_manager.hpp
@@ -94,7 +94,25 @@ namespace libtorrent {
 			// for high priority alerts, double the upper limit
 			if (m_alerts[m_generation].size() >= m_queue_size_limit
 				* (1 + T::priority))
-				return;
+			{
+				if (m_reliable_alerts)
+				{
+					do
+					{
+						m_condition.wait(lock);
+					}
+					while (m_reliable_alerts && m_alerts[m_generation].size() >=
+						m_queue_size_limit * (1 + T::priority));
+
+					// if m_reliable_alerts was cleared while we waited
+					// we may allow an alert that would've otherwise been
+					// dropped to be delivered
+				}
+				else
+				{
+					return;
+				}
+			}
 
 			T alert(m_allocations[m_generation], std::forward<Args>(args)...);
 			m_alerts[m_generation].push_back(alert);
@@ -117,7 +135,7 @@ namespace libtorrent {
 		bool should_post() const
 		{
 			mutex::scoped_lock lock(m_mutex);
-			if (m_alerts[m_generation].size() >= m_queue_size_limit
+			if (!m_reliable_alerts && m_alerts[m_generation].size() >= m_queue_size_limit
 				* (1 + T::priority))
 			{
 				return false;
@@ -141,6 +159,12 @@ namespace libtorrent {
 
 		int alert_queue_size_limit() const { return m_queue_size_limit; }
 		int set_alert_queue_size_limit(int queue_size_limit_);
+		int set_reliable_alerts(bool enabled)
+		{
+			mutex::scoped_lock lock(m_mutex);
+			this->m_reliable_alerts = enabled;
+			this->m_condition.notify_all();
+		}
 
 		void set_notify_function(boost::function<void()> const& fun);
 
@@ -166,6 +190,7 @@ namespace libtorrent {
 		condition_variable m_condition;
 		boost::uint32_t m_alert_mask;
 		int m_queue_size_limit;
+		bool m_reliable_alerts;
 
 #ifndef TORRENT_NO_DEPRECATE
 		bool maybe_dispatch(alert const& a);
diff --git a/include/libtorrent/settings_pack.hpp b/include/libtorrent/settings_pack.hpp
index df59bad47..849b4a64a 100644
--- a/include/libtorrent/settings_pack.hpp
+++ b/include/libtorrent/settings_pack.hpp
@@ -696,6 +696,13 @@ namespace libtorrent
 			// any.
 			proxy_tracker_connections,
 
+			// ``enable_reliable_alerts`` changes the behaviour of the alert
+			// manager to block instead of dropping alerts when the queue
+			// fills up. Special care must be taken when using this feature,
+			// specifically any asynchronous calls to the main thread can
+			// result in deadlock.
+			enable_reliable_alerts,
+
 			max_bool_setting_internal
 		};
 
@@ -1415,6 +1422,7 @@ namespace libtorrent
 			// fill up to this level.
 			alert_queue_size,
 
+
 			// ``max_metadata_size`` is the maximum allowed size (in bytes) to be
 			// received by the metadata extension, i.e. magnet links.
 			max_metadata_size,
diff --git a/src/alert_manager.cpp b/src/alert_manager.cpp
index ddb661986..e9fb43d8d 100644
--- a/src/alert_manager.cpp
+++ b/src/alert_manager.cpp
@@ -46,6 +46,7 @@ namespace libtorrent
 		, m_queue_size_limit(queue_limit)
 		, m_num_queued_resume(0)
 		, m_generation(0)
+		, m_reliable_alerts(true)
 	{}
 
 	alert_manager::~alert_manager() {}
@@ -182,6 +183,7 @@ namespace libtorrent
 
 		// swap buffers
 		m_generation = (m_generation + 1) & 1;
+		m_condition.notify_all();
 		// clear the one we will start writing to now
 		m_alerts[m_generation].clear();
 		m_allocations[m_generation].reset();
diff --git a/src/session.cpp b/src/session.cpp
index c9760f8ae..c78c2d4e5 100644
--- a/src/session.cpp
+++ b/src/session.cpp
@@ -418,6 +418,7 @@ namespace {
 		// stop calling the alert notify function now, to avoid it thinking the
 		// session is still alive
 		m_impl->alerts().set_notify_function(boost::function<void()>());
+		m_impl->alerts().set_reliable_alerts(false);
 		return session_proxy(m_io_service, m_thread, m_impl);
 	}
 
